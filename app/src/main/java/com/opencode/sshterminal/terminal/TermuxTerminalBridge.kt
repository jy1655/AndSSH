package com.opencode.sshterminal.terminal

import com.termux.terminal.TerminalBuffer
import com.termux.terminal.TerminalEmulator
import com.termux.terminal.KeyHandler
import com.termux.terminal.TerminalOutput
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.util.concurrent.locks.ReentrantReadWriteLock
import kotlin.concurrent.read
import kotlin.concurrent.write

class TermuxTerminalBridge(
    cols: Int = 120,
    rows: Int = 40,
    transcriptRows: Int = 2000,
    private val onWriteToSsh: (ByteArray) -> Unit,
    private val onBellReceived: () -> Unit = {},
) {
    private val lock = ReentrantReadWriteLock()
    private val _renderVersion = MutableStateFlow(0L)
    val renderVersion: StateFlow<Long> = _renderVersion.asStateFlow()

    private val output =
        object : TerminalOutput() {
            override fun write(
                data: ByteArray,
                offset: Int,
                count: Int,
            ) {
                onWriteToSsh(data.copyOfRange(offset, offset + count))
            }

            override fun titleChanged(
                oldTitle: String?,
                newTitle: String?,
            ) = Unit

            override fun onCopyTextToClipboard(text: String?) = Unit

            override fun onPasteTextFromClipboard() = Unit

            override fun onBell() {
                onBellReceived()
            }

            override fun onColorsChanged() = Unit
        }

    private val sessionClient =
        BridgeTerminalSessionClient(
            Runnable { _renderVersion.value++ },
            Runnable { onBellReceived() },
        )

    val emulator: TerminalEmulator = TerminalEmulator(output, cols, rows, transcriptRows, sessionClient)

    fun feed(bytes: ByteArray) =
        lock.write {
            emulator.append(bytes, bytes.size)
            _renderVersion.value++
        }

    fun resize(
        cols: Int,
        rows: Int,
    ) = lock.write {
        emulator.resize(cols, rows)
        _renderVersion.value++
    }

    fun reset() =
        lock.write {
            emulator.reset()
            _renderVersion.value++
        }

    fun isMouseTrackingActive(): Boolean = lock.read { emulator.isMouseTrackingActive }

    fun isAlternateBufferActive(): Boolean = lock.read { emulator.isAlternateBufferActive }

    fun sendMouseEvent(
        button: Int,
        col: Int,
        row: Int,
        pressed: Boolean,
    ) = lock.write {
        emulator.sendMouseEvent(button, col, row, pressed)
    }

    fun sendMouseWheel(
        scrollUp: Boolean,
        col: Int = cursorCol + 1,
        row: Int = cursorRow + 1,
        repeatCount: Int = 1,
    ) = lock.write {
        val button =
            if (scrollUp) {
                TerminalEmulator.MOUSE_WHEELUP_BUTTON
            } else {
                TerminalEmulator.MOUSE_WHEELDOWN_BUTTON
            }
        val safeCol = col.coerceAtLeast(1)
        val safeRow = row.coerceAtLeast(1)
        repeat(repeatCount.coerceAtLeast(1)) {
            emulator.sendMouseEvent(button, safeCol, safeRow, true)
        }
    }

    fun sendKeyCode(
        keyCode: Int,
        keyMod: Int = 0,
    ): Boolean =
        lock.read {
            val code =
                KeyHandler.getCode(
                    keyCode,
                    keyMod,
                    emulator.isCursorKeysApplicationMode,
                    emulator.isKeypadApplicationMode,
                ) ?: return false
            onWriteToSsh(code.toByteArray(Charsets.UTF_8))
            true
        }

    fun <T> withReadLock(block: TermuxTerminalBridge.() -> T): T = lock.read { block() }

    val screen: TerminalBuffer get() = emulator.screen
    val cursorRow: Int get() = emulator.cursorRow
    val cursorCol: Int get() = emulator.cursorCol
    val termRows: Int get() = emulator.mRows
    val termCols: Int get() = emulator.mColumns
}
